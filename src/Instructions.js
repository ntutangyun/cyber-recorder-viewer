function Instructions() {
    return <div>
        <h2>Introduction</h2>
        <p>
            This website can be used to understand or validate the data saved in the Baidu Apollo's recording files
            (produced by cyber_recorder command).
        </p>
        <h2>Cyber Recording File</h2>
        <p>The recording file is a binary file of a fixed format. It consists of
            1 <strong>Header</strong> section, 1 <strong>Index</strong> section and 1+ <strong>Channel</strong> sections
            and 1+ <strong>Chunk HEADER + Chunk Body</strong> sections, saved in the following order</p>
        <code>[Header Section] [empty padding] [Channel Section 1] [Channel Section 2] ... [Chunk Header 1] [Chunk Body
            1] [Chunk Header 2] [Chunk Body 2] ... [Index Section]</code>
        <h2>Section Binary format</h2>
        <p>Each section has a fixed length section head (16 bytes) followed by flexible length section body. Sections
            have the following structure: </p>
        <table className={"instruction-table"}>
            <thead>
            <tr>
                <th>position</th>
                <th>data</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>0 - 3</td>
                <td>XX XX XX XX</td>
                <td>
                    <div>
                        The first four bytes records signed 32 bit integer (little endian) whose value is the
                        section type. The section types are defined in the file: <code>cyber/proto/record.proto</code>
                    </div>
                    <ul>
                        <li>"SECTION_HEADER": 0</li>
                        <li>"SECTION_CHUNK_HEADER": 1</li>
                        <li>"SECTION_CHUNK_BODY": 2</li>
                        <li>"SECTION_INDEX": 3</li>
                        <li>"SECTION_CHANNEL": 4</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>4 - 7</td>
                <td>00 00 00 00</td>
                <td>
                    These four bytes are empty for padding purpose.
                </td>
            </tr>
            <tr>
                <td>8 - 15</td>
                <td>XX XX XX XX XX XX XX XX</td>
                <td>
                    The next 8 bytes records signed 64 bit integer (little endian) whose value is the number of
                    bytes of the section body (which follows the section head), a.k.a. section body size.
                </td>
            </tr>
            <tr>
                <td>16 - (16 + section body size - 1)</td>
                <td>XX XX XX XX ...</td>
                <td>
                    <div>
                        The section body is parsed according to the section type defined in the section head. Section
                        body are the encoded messages using protobuf libraries and thus can be decoded using
                        corresponding libraries generated by <code>protoc</code>.
                    </div>
                    <div>
                        For example, the first section is usually the Header Section, and the section body can be
                        decoded by: <code>Header.deserializeBinary(buf).toObject()</code>, where <code>Header</code> is
                        imported from protobuf libraries generated by <code>protoc</code>.
                    </div>
                </td>
            </tr>
            </tbody>
        </table>

        <h2>Section Semantics</h2>

        <table className={"instruction-table"}>
            <thead>
            <tr>
                <th>Section Type</th>
                <th>Description</th>
            </tr>
            </thead>
            <tbody>
            <tr>
                <td>SECTION_HEADER</td>
                <td>
                    <div>
                        Header section records the following information:
                    </div>
                    <ul>
                        <li>chunk_interval: limits the duration of each chunk</li>
                        <li>segment_interval: limits the duration of each recording segment file</li>
                        <li>index_position: the starting position of the last index section</li>
                        <li>chunk_number: number of chunks saved in this file</li>
                        <li>channel_number: number of channels in total in this file</li>
                        <li>begin_time</li>
                        <li>end_time</li>
                        <li>message_number: number of messages in total</li>
                        <li>size: total file size</li>
                        <li>...</li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>SECTION_CHANNEL</td>
                <td>
                    Channel Section records the channel name and message type. e.g. name:
                    "/apollo/perception/obstacles" and type: "apollo.perception.PerceptionObstacles"
                </td>
            </tr>
            <tr>
                <td>SECTION_CHUNK_HEADER</td>
                <td>
                    The chunk header section indicates the start of a message chunk. It records the chunk's start
                    timestamp and end timestamp as well as total number of messages saved in the chunk body section.
                </td>
            </tr>
            <tr>
                <td>SECTION_CHUNK_BODY</td>
                <td>
                    <div>
                        The chunk body section follows its chunk header section. It contains a message list which
                        consists of all the cyber messages recorded during the period of the current chunk, ordered by
                        message time. Each message in the list contains the following fields:
                    </div>
                    <ul>
                        <li>channelName: e.g. /apollo/sensor/gnss/corrected_imu</li>
                        <li>time: message timestamp</li>
                        <li>content: a string representing the protobuf encoded binary data of the message. The content
                            of the message can be decoded
                            by <code>MessageClass.deserializeBinary(string).toObject()</code>,
                            where <code>MessageClass</code> is imported from protobuf libraries generated
                            by <code>protoc</code></li>
                    </ul>
                </td>
            </tr>
            <tr>
                <td>SECTION_INDEX</td>
                <td>
                    The index section is located at the end of each recording file. Its starting position is saved in
                    the Header section. It saves the index list which records the starting positions and other
                    information (e.g. number of messages, begin time, end time etc.) of all the Channel sections, Chunk
                    Header sections and Chunk Body sections.
                </td>
            </tr>
            </tbody>
        </table>

        <h2>Usage</h2>
        <ol>
            <li>
                <div>
                    Generate protobuf libraries using <code>protoc</code>.
                </div>
                <ol>
                    <li>Enter Apollo terminal</li>
                    <li>Create a temporary folder, e.g. <code>/apollo/protobuf_out</code></li>
                    <li>Use following command to generate protobuf libraries and save to
                        the <code>protobuf_out</code> folder <br/>
                        <code>find modules/ cyber/ -name "*.proto" | grep -v
                            node_modules | xargs protoc --js_out=import_style=library,binary:protobuf_out</code>
                    </li>
                    <li>If you encounter errors related to conflicts in yolo.proto and yolo4.proto, you may comment out
                        unused proto files and try again.
                    </li>
                </ol>
            </li>
            <li>
                <div>
                    Import the generated JavaScript libraries
                </div>
                <ol>
                    <li>Navigate to the top of this website, and click the "Choose files" button in the middle.</li>
                    <li>Navigate to the <code>protobuf_out</code> folder and select all the <code>.js</code> files
                    </li>
                    <li>Wait for some time and let the browser load those libraries. When ready, the "choose file"
                        button on the right will be enabled.
                    </li>
                </ol>
            </li>
            <li>
                <div>
                    Import the cyber recording file. Currently only supports one file at a time.
                </div>
                <ol>
                    <li>Navigate to the top of the website, and click the "Choose file" button at the right end.</li>
                    <li>Select any recording file</li>
                    <li>Wait for some time to parse the file. When the parsing is done, you can scroll down and check
                        out the results.
                    </li>
                </ol>
            </li>
        </ol>

        <h2>Author</h2>
        <p>Apollo's 社区布道师 <strong>Tang Yun</strong> (ntutangyun [at] gmail [dot] com)</p>
        <p>My current research interest is <strong>software testing of Autonomous vehicles</strong>. Feel free to drop
            me an email for research collaborations. :)</p>
        <p>The repository address is https://github.com/ntutangyun/cyber-recorder-viewer.
            Feel free to create forks and pull requests.</p>
        <p>Kindly acknowledge if you use any code from this repository :)</p>
    </div>;
}

export default Instructions;