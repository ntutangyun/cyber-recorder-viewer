{"version":3,"sources":["TitleBar.js","utils/ioUtils.js","utils/recordUtils.js","Instructions.js","App.js","index.js"],"names":["styles","TitleBar","recordParser","setProtoObj","setRecording","onProtobufLibsSelected","e","a","console","log","target","files","Array","from","fileContentList","file","name","readFileText","fileContent","push","forEach","eval","proto","onRecordingFileSelected","readFileArrayBuffer","arrayBuffer","className","type","multiple","onChange","disabled","Promise","resolve","reader","FileReader","onload","evt","result","readAsText","readAsArrayBuffer","bufferToHexLimitLength","buffer","length","bufferString","Uint8Array","map","b","toString","padStart","join","toUpperCase","slice","onClick","title","SectionData","startPosition","this","typeName","class","size","bodyObject","typeBuffer","padBuffer","sizeBuffer","bodyBuffer","buf","DataView","getInt32","Number","getBigInt64","deserializeBinary","toObject","src","collapseStringsAfterLength","collapsed","groupArraysAfterLength","RecordParser","protoObj","Header","apollo","cyber","SectionType","Index","Channel","ChunkHeader","ChunkBody","ChannelCache","recording","readPosition","headerSection","indexSection","channelInfo","sectionList","currentChunk","reset","readHeader","readIndex","readChunks","newSection","sort","readSectionHead","assignSectionClass","SECTION_HEADER","Error","readSectionBody","updateSectionList","setPosition","SECTION_LENGTH","isComplete","indexPosition","SECTION_INDEX","indexesList","singleIdx","SECTION_CHANNEL","channelCache","assignChannelCacheParser","parser","messageType","split","reduce","o","i","reachEnd","section","skipPadding","SECTION_CHUNK_HEADER","SECTION_CHUNK_BODY","messagesList","msg","hasOwnProperty","channelName","parsedMessageContent","content","error","setTypeBuffer","readBytes","setPadBuffer","setSizeBuffer","setBodyBuffer","byteLength","position","Instructions","App","useState","setRecordParser","setSectionList","useEffect","parse","renderSection","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.d0037e88.chunk.js","sourcesContent":["/* eslint-disable no-undef */\nimport React from \"react\";\nimport {readFileArrayBuffer, readFileText} from \"./utils/ioUtils\";\n\nconst styles = {};\n\nfunction TitleBar({recordParser, setProtoObj, setRecording}) {\n    const onProtobufLibsSelected = async (e) => {\n        console.log(e.target.files);\n        console.log(Array.from(e.target.files));\n\n        const fileContentList = [];\n        for (const file of Array.from(e.target.files)) {\n            console.log(`processing: ${file.name}`);\n            const fileContent = await readFileText(file);\n            fileContentList.push(fileContent);\n        }\n\n        fileContentList.forEach(fileContent => {\n            eval(fileContent);\n        });\n\n        setProtoObj(proto);\n    };\n\n    const onRecordingFileSelected = async (e) => {\n        const arrayBuffer = await readFileArrayBuffer(e.target.files[0]);\n        setRecording(arrayBuffer);\n    };\n\n    return (\n        <header className={\"flex-row justify-content-between\"}>\n            <h1>Apollo Cyber Record Viewer</h1>\n            <label>\n                import all protobuf_out files\n                <input type=\"file\" multiple onChange={onProtobufLibsSelected}/>\n            </label>\n            <label>\n                Select recording file\n                <input type=\"file\" onChange={onRecordingFileSelected} disabled={recordParser === null}/>\n            </label>\n        </header>\n    );\n}\n\nexport default TitleBar;\n","function readFileText(file) {\n    return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onload = (evt) => {\n            resolve(evt.target.result);\n        };\n        reader.readAsText(file);\n    });\n}\n\nfunction readFileArrayBuffer(file) {\n    return new Promise(resolve => {\n        const reader = new FileReader();\n        reader.onload = (evt) => {\n            resolve(evt.target.result);\n        };\n        reader.readAsArrayBuffer(file);\n    });\n}\n\nfunction bufferToHex(buffer) {\n    return [...new Uint8Array(buffer)]\n        .map(b => b.toString(16).padStart(2, \"0\")).join(\" \").toUpperCase();\n}\n\nfunction bufferToHexLimitLength(buffer, length = 300) {\n    const bufferString = [...new Uint8Array(buffer)]\n        .map(b => b.toString(16).padStart(2, \"0\")).join(\" \").toUpperCase();\n\n    if (bufferString.length <= length) {\n        return bufferString;\n    } else {\n        return <>\n            {bufferString.slice(0, length)} ...\n            <button onClick={() => {\n                console.log(buffer);\n                console.log(bufferString);\n            }} title={\"Click to log the raw buffer to console\"}>\n                Log buffer\n            </button>\n        </>;\n    }\n}\n\n\nexport {\n    readFileText,\n    readFileArrayBuffer,\n    bufferToHexLimitLength,\n    bufferToHex\n};","/* eslint-disable no-undef */\nimport ReactJson from \"react-json-view\";\nimport {bufferToHexLimitLength} from \"./ioUtils\";\n\nconst SECTION_LENGTH = 16;\nconst HEADER_LENGTH = 2048;\n\nclass SectionData {\n    constructor(startPosition) {\n        this.startPosition = startPosition;\n\n        this.type = null;\n        this.typeName = null;\n        this.class = null;\n        this.size = null;\n        this.bodyObject = null;\n\n        this.typeBuffer = null;\n        this.padBuffer = null;\n        this.sizeBuffer = null;\n        this.bodyBuffer = null;\n    }\n\n    setTypeBuffer(buf) {\n        this.typeBuffer = buf;\n        this.type = new DataView(buf).getInt32(0, true);\n    }\n\n    setSizeBuffer(buf) {\n        this.sizeBuffer = buf;\n        this.size = Number(new DataView(buf).getBigInt64(0, true));\n    }\n\n    setPadBuffer(buf) {\n        this.padBuffer = buf;\n    }\n\n    setBodyBuffer(buf) {\n        this.bodyBuffer = buf;\n        this.bodyObject = this.class.deserializeBinary(buf).toObject();\n    }\n\n    renderSection() {\n        return <table className={\"byte-table\"}>\n            <thead>\n            <tr>\n                <th>Position</th>\n                <th>Byte Size</th>\n                <th>Raw Bytes</th>\n                <th>Value</th>\n                {/*<th>Description</th>*/}\n            </tr>\n            </thead>\n            <tbody>\n            <tr>\n                {/* 0 - 3 section type*/}\n                <td className={\"byte-table-position-column\"}>{this.startPosition} - {this.startPosition + 3}</td>\n                <td className={\"byte-table-byte-size-column\"}>4</td>\n                <td className={\"byte-table-byte-column\"}>{bufferToHexLimitLength(this.typeBuffer)}</td>\n                <td>{this.type} ({this.typeName})</td>\n                {/*<td style=width: {}>These four bytes records the type of the following section body part.*/}\n                {/*    The data is saved as signed integer 32 bit in little endian format.*/}\n                {/*</td>*/}\n            </tr>\n            <tr>\n                {/* 4 - 7 section padding */}\n                <td className={\"byte-table-position-column\"}>{this.startPosition + 4} - {this.startPosition + 7}</td>\n                <td className={\"byte-table-byte-size-column\"}>4</td>\n                <td className={\"byte-table-byte-column\"}>{bufferToHexLimitLength(this.typeBuffer)}</td>\n                <td>&nbsp;-&nbsp;</td>\n                {/*<td style=width: {}>These four bytes is for padding purpose. Can be ignored.</td>*/}\n            </tr>\n            <tr>\n                {/* 8 - 15 section padding */}\n                <td className={\"byte-table-position-column\"}>{this.startPosition + 8} - {this.startPosition + 15}</td>\n                <td className={\"byte-table-byte-size-column\"}>8</td>\n                <td className={\"byte-table-byte-column\"}>{bufferToHexLimitLength(this.sizeBuffer)}</td>\n                <td>{this.size}</td>\n                {/*<td style=width: {}>These eight bytes records the size of the following section body part. The data is saved as signed*/}\n                {/*    integer 64 bit in little endian format.*/}\n                {/*</td>*/}\n            </tr>\n            <tr>\n                {/*16 - 16 + section.size - 1  section body*/}\n                <td className={\"byte-table-position-column\"}>{this.startPosition + 16} - {this.startPosition + 16 + this.size - 1}</td>\n                <td className={\"byte-table-byte-size-column\"}>{this.size}</td>\n                <td className={\"byte-table-byte-column\"}>{bufferToHexLimitLength(this.bodyBuffer)}</td>\n                <td>\n                    {\n                        // use browser's default console to view the big data\n                        this.type === 2 && <button onClick={() => console.log(this.bodyObject)}\n                                                   title={\"Click to log the parsed chunk body to the browser console.\"}>Log\n                            Chunk Body to Console\n                        </button>\n                    }\n                    {\n                        this.type !== 2 && <ReactJson src={this.bodyObject}\n                                                      collapseStringsAfterLength={50}\n                                                      collapsed={3}\n                                                      groupArraysAfterLength={100}/>\n                    }\n                </td>\n            </tr>\n            </tbody>\n        </table>;\n    }\n}\n\nclass RecordParser {\n    constructor(protoObj) {\n        this.protoObj = protoObj;\n\n        this.Header = protoObj.apollo.cyber.proto.Header;\n        this.SectionType = protoObj.apollo.cyber.proto.SectionType;\n        this.Index = protoObj.apollo.cyber.proto.Index;\n        this.Channel = protoObj.apollo.cyber.proto.Channel;\n        this.ChunkHeader = protoObj.apollo.cyber.proto.ChunkHeader;\n        this.ChunkBody = protoObj.apollo.cyber.proto.ChunkBody;\n        this.ChannelCache = protoObj.apollo.cyber.proto.ChannelCache;\n\n        this.recording = null;\n        this.readPosition = 0;\n\n        // record data\n        this.headerSection = null;\n        this.indexSection = null;\n        this.channelInfo = {};\n        this.sectionList = [];\n\n        this.currentChunk = null;\n\n        console.log(this.SectionType);\n    }\n\n    reset() {\n        this.recording = null;\n        this.readPosition = 0;\n        this.headerSection = null;\n        this.indexSection = null;\n        this.channelInfo = {};\n        this.sectionList = [];\n\n        this.currentChunk = null;\n    }\n\n    parse(recording) {\n        this.reset();\n        this.recording = recording;\n\n        this.readHeader();\n        this.readIndex();\n        this.readChunks();\n\n        console.log(this.sectionList);\n    }\n\n    updateSectionList(newSection) {\n        this.sectionList.push(newSection);\n        this.sectionList.sort((a, b) => a.startPosition - b.startPosition);\n    }\n\n    readHeader() {\n        console.log(\"reading header\");\n        this.headerSection = new SectionData(this.readPosition);\n        this.readSectionHead(this.headerSection);\n        this.assignSectionClass(this.headerSection);\n\n        if (this.headerSection.type !== this.SectionType.SECTION_HEADER) {\n            throw new Error(`readHeader: check section type failed: ${this.headerSection.type}`);\n        }\n\n        this.readSectionBody(this.headerSection);\n        this.updateSectionList(this.headerSection);\n\n        this.setPosition(SECTION_LENGTH + HEADER_LENGTH);\n        return true;\n    }\n\n    readIndex() {\n        if (!this.headerSection.bodyObject.isComplete) {\n            throw new Error(\"recording file is not complete\");\n        }\n\n        this.setPosition(this.headerSection.bodyObject.indexPosition);\n\n        this.indexSection = new SectionData(this.readPosition);\n        this.readSectionHead(this.indexSection);\n        this.assignSectionClass(this.indexSection);\n\n        if (this.indexSection.type !== this.SectionType.SECTION_INDEX) {\n            throw new Error(\"readHeader: check section type failed\");\n        }\n\n        this.readSectionBody(this.indexSection);\n\n        this.indexSection.bodyObject.indexesList.forEach(singleIdx => {\n            if (singleIdx.type !== this.SectionType.SECTION_CHANNEL) {\n                return;\n            }\n            if (!singleIdx.channelCache) {\n                console.log(`single channel index does not have channel cache.`);\n                return;\n            }\n\n            const channelCache = singleIdx.channelCache;\n            this.assignChannelCacheParser(channelCache);\n            this.channelInfo[channelCache.name] = channelCache;\n        });\n        console.log(this.channelInfo);\n        console.log(proto);\n        this.updateSectionList(this.indexSection);\n\n        this.setPosition(SECTION_LENGTH + HEADER_LENGTH);\n    }\n\n    assignChannelCacheParser(channelCache) {\n        channelCache.parser = channelCache.messageType.split(\".\").reduce((o, i) => o[i], this.protoObj);\n    }\n\n    readChunks() {\n        let reachEnd = false;\n\n        while (!reachEnd) {\n            const section = new SectionData(this.readPosition);\n            this.readSectionHead(section);\n            this.assignSectionClass(section);\n\n            switch (section.type) {\n                case this.SectionType.SECTION_INDEX: {\n                    console.log(`Read index section of size: ${section.size}`);\n                    this.skipPadding(section.size);\n                    reachEnd = true;\n                    break;\n                }\n                case this.SectionType.SECTION_CHANNEL: {\n                    console.log(`Read channel section of size: ${section.size}`);\n                    this.readSectionBody(section);\n                    // console.log(`name: ${section.bodyObject.name}, type: ${section.bodyObject.name.messageType}`);\n                    this.updateSectionList(section);\n                    break;\n                }\n                case this.SectionType.SECTION_CHUNK_HEADER: {\n                    console.log(`Read chunk header section of size: ${section.size}`);\n                    this.readSectionBody(section);\n                    this.updateSectionList(section);\n                    break;\n                }\n                case this.SectionType.SECTION_CHUNK_BODY: {\n                    console.log(`Read chunk body section of size: ${section.size}`);\n                    this.readSectionBody(section);\n\n                    section.bodyObject.messagesList.forEach(msg => {\n                        if (!this.channelInfo.hasOwnProperty(msg.channelName) || !this.channelInfo[msg.channelName].parser) {\n                            throw new Error(`Error parsing message of chunk body: ${msg.channelName}`);\n                        }\n                        msg.parsedMessageContent = this.channelInfo[msg.channelName].parser.deserializeBinary(msg.content).toObject();\n                    });\n                    this.updateSectionList(section);\n                    break;\n                }\n                default: {\n                    console.error(`Invalid section type: ${section.type} size ${section.size}`);\n                    return false;\n                }\n            }\n        }\n    }\n\n    assignSectionClass(section) {\n        switch (section.type) {\n            case this.SectionType.SECTION_HEADER: {\n                section.class = this.Header;\n                section.typeName = \"SECTION_HEADER\";\n                break;\n            }\n            case this.SectionType.SECTION_CHUNK_HEADER: {\n                section.class = this.ChunkHeader;\n                section.typeName = \"SECTION_CHUNK_HEADER\";\n                break;\n            }\n            case this.SectionType.SECTION_CHUNK_BODY: {\n                section.class = this.ChunkBody;\n                section.typeName = \"SECTION_CHUNK_BODY\";\n                break;\n            }\n            case this.SectionType.SECTION_INDEX: {\n                section.class = this.Index;\n                section.typeName = \"SECTION_INDEX\";\n                break;\n            }\n            case this.SectionType.SECTION_CHANNEL: {\n                section.class = this.Channel;\n                section.typeName = \"SECTION_CHANNEL\";\n                break;\n            }\n            default: {\n                throw new Error(`Assign section class failed: unknown section type: ${section.type}`);\n            }\n        }\n    }\n\n    readSectionHead(section) {\n        section.setTypeBuffer(this.readBytes(4), this.SectionType);\n        section.setPadBuffer(this.readBytes(4));\n        section.setSizeBuffer(this.readBytes(8));\n\n        return section;\n    }\n\n    readSectionBody(section) {\n        section.setBodyBuffer(this.readBytes(section.size));\n    }\n\n    readBytes(size) {\n        const buf = this.recording.slice(this.readPosition, this.readPosition + size);\n        if (buf.byteLength !== size) {\n            throw new Error(`read bytes of size ${size} error from index: ${this.readPosition}, the recording length is ${this.recording.byteLength}`);\n        }\n        this.readPosition += size;\n        return buf;\n    }\n\n    skipPadding(size) {\n        this.readPosition += size;\n    }\n\n    setPosition(position) {\n        this.readPosition = position;\n    }\n}\n\nexport {\n    RecordParser\n};\n;","function Instructions() {\n    return <div>\n        <h2>Introduction</h2>\n        <p>\n            This website can be used to understand or validate the data saved in the Baidu Apollo's recording files\n            (produced by cyber_recorder command).\n        </p>\n        <h2>Cyber Recording File</h2>\n        <p>The recording file is a binary file of a fixed format. It consists of\n            1 <strong>Header</strong> section, 1 <strong>Index</strong> section and 1+ <strong>Channel</strong> sections\n            and 1+ <strong>Chunk HEADER + Chunk Body</strong> sections, saved in the following order</p>\n        <code>[Header Section] [empty padding] [Channel Section 1] [Channel Section 2] ... [Chunk Header 1] [Chunk Body\n            1] [Chunk Header 2] [Chunk Body 2] ... [Index Section]</code>\n        <h2>Section Binary format</h2>\n        <p>Each section has a fixed length section head (16 bytes) followed by flexible length section body. Sections\n            have the following structure: </p>\n        <table className={\"instruction-table\"}>\n            <thead>\n            <tr>\n                <th>position</th>\n                <th>data</th>\n                <th>Description</th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr>\n                <td>0 - 3</td>\n                <td>XX XX XX XX</td>\n                <td>\n                    <div>\n                        The first four bytes records signed 32 bit integer (little endian) whose value is the\n                        section type. The section types are defined in the file: <code>cyber/proto/record.proto</code>\n                    </div>\n                    <ul>\n                        <li>\"SECTION_HEADER\": 0</li>\n                        <li>\"SECTION_CHUNK_HEADER\": 1</li>\n                        <li>\"SECTION_CHUNK_BODY\": 2</li>\n                        <li>\"SECTION_INDEX\": 3</li>\n                        <li>\"SECTION_CHANNEL\": 4</li>\n                    </ul>\n                </td>\n            </tr>\n            <tr>\n                <td>4 - 7</td>\n                <td>00 00 00 00</td>\n                <td>\n                    These four bytes are empty for padding purpose.\n                </td>\n            </tr>\n            <tr>\n                <td>8 - 15</td>\n                <td>XX XX XX XX XX XX XX XX</td>\n                <td>\n                    The next 8 bytes records signed 64 bit integer (little endian) whose value is the number of\n                    bytes of the section body (which follows the section head), a.k.a. section body size.\n                </td>\n            </tr>\n            <tr>\n                <td>16 - (16 + section body size - 1)</td>\n                <td>XX XX XX XX ...</td>\n                <td>\n                    <div>\n                        The section body is parsed according to the section type defined in the section head. Section\n                        body are the encoded messages using protobuf libraries and thus can be decoded using\n                        corresponding libraries generated by <code>protoc</code>.\n                    </div>\n                    <div>\n                        For example, the first section is usually the Header Section, and the section body can be\n                        decoded by: <code>Header.deserializeBinary(buf).toObject()</code>, where <code>Header</code> is\n                        imported from protobuf libraries generated by <code>protoc</code>.\n                    </div>\n                </td>\n            </tr>\n            </tbody>\n        </table>\n\n        <h2>Section Semantics</h2>\n\n        <table className={\"instruction-table\"}>\n            <thead>\n            <tr>\n                <th>Section Type</th>\n                <th>Description</th>\n            </tr>\n            </thead>\n            <tbody>\n            <tr>\n                <td>SECTION_HEADER</td>\n                <td>\n                    <div>\n                        Header section records the following information:\n                    </div>\n                    <ul>\n                        <li>chunk_interval: limits the duration of each chunk</li>\n                        <li>segment_interval: limits the duration of each recording segment file</li>\n                        <li>index_position: the starting position of the last index section</li>\n                        <li>chunk_number: number of chunks saved in this file</li>\n                        <li>channel_number: number of channels in total in this file</li>\n                        <li>begin_time</li>\n                        <li>end_time</li>\n                        <li>message_number: number of messages in total</li>\n                        <li>size: total file size</li>\n                        <li>...</li>\n                    </ul>\n                </td>\n            </tr>\n            <tr>\n                <td>SECTION_CHANNEL</td>\n                <td>\n                    Channel Section records the channel name and message type. e.g. name:\n                    \"/apollo/perception/obstacles\" and type: \"apollo.perception.PerceptionObstacles\"\n                </td>\n            </tr>\n            <tr>\n                <td>SECTION_CHUNK_HEADER</td>\n                <td>\n                    The chunk header section indicates the start of a message chunk. It records the chunk's start\n                    timestamp and end timestamp as well as total number of messages saved in the chunk body section.\n                </td>\n            </tr>\n            <tr>\n                <td>SECTION_CHUNK_BODY</td>\n                <td>\n                    <div>\n                        The chunk body section follows its chunk header section. It contains a message list which\n                        consists of all the cyber messages recorded during the period of the current chunk, ordered by\n                        message time. Each message in the list contains the following fields:\n                    </div>\n                    <ul>\n                        <li>channelName: e.g. /apollo/sensor/gnss/corrected_imu</li>\n                        <li>time: message timestamp</li>\n                        <li>content: a string representing the protobuf encoded binary data of the message. The content\n                            of the message can be decoded\n                            by <code>MessageClass.deserializeBinary(string).toObject()</code>,\n                            where <code>MessageClass</code> is imported from protobuf libraries generated\n                            by <code>protoc</code></li>\n                    </ul>\n                </td>\n            </tr>\n            <tr>\n                <td>SECTION_INDEX</td>\n                <td>\n                    The index section is located at the end of each recording file. Its starting position is saved in\n                    the Header section. It saves the index list which records the starting positions and other\n                    information (e.g. number of messages, begin time, end time etc.) of all the Channel sections, Chunk\n                    Header sections and Chunk Body sections.\n                </td>\n            </tr>\n            </tbody>\n        </table>\n\n        <h2>Usage</h2>\n        <ol>\n            <li>\n                <div>\n                    Generate protobuf libraries using <code>protoc</code>.\n                </div>\n                <ol>\n                    <li>Enter Apollo terminal</li>\n                    <li>Create a temporary folder, e.g. <code>/apollo/protobuf_out</code></li>\n                    <li>Use following command to generate protobuf libraries and save to\n                        the <code>protobuf_out</code> folder <br/>\n                        <code>find modules/ cyber/ -name \"*.proto\" | grep -v\n                            node_modules | xargs protoc --js_out=import_style=library,binary:protobuf_out</code>\n                    </li>\n                    <li>If you encounter errors related to conflicts in yolo.proto and yolo4.proto, you may comment out\n                        unused proto files and try again.\n                    </li>\n                </ol>\n            </li>\n            <li>\n                <div>\n                    Import the generated JavaScript libraries\n                </div>\n                <ol>\n                    <li>Navigate to the top of this website, and click the \"Choose files\" button in the middle.</li>\n                    <li>Navigate to the <code>protobuf_out</code> folder and select all the <code>.js</code> files\n                    </li>\n                    <li>Wait for some time and let the browser load those libraries. When ready, the \"choose file\"\n                        button on the right will be enabled.\n                    </li>\n                </ol>\n            </li>\n            <li>\n                <div>\n                    Import the cyber recording file. Currently only supports one file at a time.\n                </div>\n                <ol>\n                    <li>Navigate to the top of the website, and click the \"Choose file\" button at the right end.</li>\n                    <li>Select any recording file</li>\n                    <li>Wait for some time to parse the file. When the parsing is done, you can scroll down and check\n                        out the results.\n                    </li>\n                </ol>\n            </li>\n        </ol>\n\n        <h2>Author</h2>\n        <p>Apollo's 社区布道师 <strong>Tang Yun</strong> (ntutangyun [at] gmail [dot] com)</p>\n        <p>My current research interest is <strong>software testing of Autonomous vehicles</strong>. Feel free to drop\n            me an email for research collaborations. :)</p>\n        <p>The repository address is https://github.com/ntutangyun/cyber-recorder-viewer.\n            Feel free to create forks and pull requests.</p>\n        <p>Kindly acknowledge if you use any code from this repository :)</p>\n    </div>;\n}\n\nexport default Instructions;","import \"./App.css\";\nimport TitleBar from \"./TitleBar\";\nimport {useEffect, useState} from \"react\";\nimport {RecordParser} from \"./utils/recordUtils\";\nimport Instructions from \"./Instructions\";\n\nfunction App() {\n    const [protoObj, setProtoObj] = useState(null);\n    const [recording, setRecording] = useState(null);\n    const [recordParser, setRecordParser] = useState(null);\n    const [sectionList, setSectionList] = useState([]);\n\n    useEffect(() => {\n        if (protoObj !== null) {\n            const recordParser = new RecordParser(protoObj);\n            setRecordParser(recordParser);\n        }\n    }, [protoObj]);\n\n    useEffect(() => {\n        if (recording !== null) {\n            console.log(recording);\n            recordParser.parse(recording);\n            setSectionList(recordParser.sectionList);\n        }\n    }, [recording]);\n\n    return (\n        <div className=\"App\">\n            <TitleBar recordParser={recordParser} setProtoObj={setProtoObj} setRecording={setRecording}/>\n            <Instructions/>\n            {\n                sectionList && sectionList.length > 0 &&\n                sectionList.map((section, i) =>\n                    <div key={i}>\n                        <h1>Section {section.typeName}</h1>\n                        <hr/>\n                        <div>\n                            {section.renderSection()}\n                        </div>\n                    </div>\n                )\n            }\n        </div>\n    );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport \"antd/dist/antd.css\";\nimport App from \"./App\";\n\n\nReactDOM.render(\n    <React.StrictMode>\n        <App/>\n    </React.StrictMode>,\n    document.getElementById(\"root\")\n);"],"sourceRoot":""}